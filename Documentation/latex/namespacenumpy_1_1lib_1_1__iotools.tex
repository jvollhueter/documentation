\hypertarget{namespacenumpy_1_1lib_1_1__iotools}{}\doxysection{numpy.\+lib.\+\_\+iotools Namespace Reference}
\label{namespacenumpy_1_1lib_1_1__iotools}\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}A collection of functions designed to help I/O with ascii files.\end{DoxyVerb}
 \doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1LineSplitter}{Line\+Splitter}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1NameValidator}{Name\+Validator}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1ConverterError}{Converter\+Error}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1ConverterLockError}{Converter\+Lock\+Error}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1ConversionWarning}{Conversion\+Warning}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1StringConverter}{String\+Converter}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_a963397b6c785faf85aa430b490365798}{has\+\_\+nested\+\_\+fields}} (ndtype)
\item 
def \mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_ae64e910fdeae338f1f962ff03efb841e}{flatten\+\_\+dtype}} (ndtype, flatten\+\_\+base=False)
\item 
def \mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_a4ecb79a687b0f134273b11e96703f23f}{str2bool}} (value)
\item 
def \mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_a5739d8ab0039f219256bb18dc1c8e918}{easy\+\_\+dtype}} (ndtype, names=None, defaultfmt=\char`\"{}f\%i\char`\"{}, $\ast$$\ast$validationargs)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacenumpy_1_1lib_1_1__iotools_a5739d8ab0039f219256bb18dc1c8e918}\label{namespacenumpy_1_1lib_1_1__iotools_a5739d8ab0039f219256bb18dc1c8e918}} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!easy\_dtype@{easy\_dtype}}
\index{easy\_dtype@{easy\_dtype}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{easy\_dtype()}{easy\_dtype()}}
{\footnotesize\ttfamily def numpy.\+lib.\+\_\+iotools.\+easy\+\_\+dtype (\begin{DoxyParamCaption}\item[{}]{ndtype,  }\item[{}]{names = {\ttfamily None},  }\item[{}]{defaultfmt = {\ttfamily \char`\"{}f\%i\char`\"{}},  }\item[{$\ast$$\ast$}]{validationargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convenience function to create a `np.dtype` object.

The function processes the input `dtype` and matches it with the given
names.

Parameters
----------
ndtype : var
    Definition of the dtype. Can be any string or dictionary recognized
    by the `np.dtype` function, or a sequence of types.
names : str or sequence, optional
    Sequence of strings to use as field names for a structured dtype.
    For convenience, `names` can be a string of a comma-separated list
    of names.
defaultfmt : str, optional
    Format string used to define missing names, such as ``"f%i"``
    (default) or ``"fields_%02i"``.
validationargs : optional
    A series of optional arguments used to initialize a
    `NameValidator`.

Examples
--------
>>> np.lib._iotools.easy_dtype(float)
dtype('float64')
>>> np.lib._iotools.easy_dtype("i4, f8")
dtype([('f0', '<i4'), ('f1', '<f8')])
>>> np.lib._iotools.easy_dtype("i4, f8", defaultfmt="field_%03i")
dtype([('field_000', '<i4'), ('field_001', '<f8')])

>>> np.lib._iotools.easy_dtype((int, float, float), names="a,b,c")
dtype([('a', '<i8'), ('b', '<f8'), ('c', '<f8')])
>>> np.lib._iotools.easy_dtype(float, names="a,b,c")
dtype([('a', '<f8'), ('b', '<f8'), ('c', '<f8')])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1__iotools_ae64e910fdeae338f1f962ff03efb841e}\label{namespacenumpy_1_1lib_1_1__iotools_ae64e910fdeae338f1f962ff03efb841e}} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!flatten\_dtype@{flatten\_dtype}}
\index{flatten\_dtype@{flatten\_dtype}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{flatten\_dtype()}{flatten\_dtype()}}
{\footnotesize\ttfamily def numpy.\+lib.\+\_\+iotools.\+flatten\+\_\+dtype (\begin{DoxyParamCaption}\item[{}]{ndtype,  }\item[{}]{flatten\+\_\+base = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Unpack a structured data-type by collapsing nested fields and/or fields
with a shape.

Note that the field names are lost.

Parameters
----------
ndtype : dtype
    The datatype to collapse
flatten_base : bool, optional
   If True, transform a field with a shape into several fields. Default is
   False.

Examples
--------
>>> dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),
...                ('block', int, (2, 3))])
>>> np.lib._iotools.flatten_dtype(dt)
[dtype('S4'), dtype('float64'), dtype('float64'), dtype('int64')]
>>> np.lib._iotools.flatten_dtype(dt, flatten_base=True)
[dtype('S4'),
 dtype('float64'),
 dtype('float64'),
 dtype('int64'),
 dtype('int64'),
 dtype('int64'),
 dtype('int64'),
 dtype('int64'),
 dtype('int64')]\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1__iotools_a963397b6c785faf85aa430b490365798}\label{namespacenumpy_1_1lib_1_1__iotools_a963397b6c785faf85aa430b490365798}} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!has\_nested\_fields@{has\_nested\_fields}}
\index{has\_nested\_fields@{has\_nested\_fields}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{has\_nested\_fields()}{has\_nested\_fields()}}
{\footnotesize\ttfamily def numpy.\+lib.\+\_\+iotools.\+has\+\_\+nested\+\_\+fields (\begin{DoxyParamCaption}\item[{}]{ndtype }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns whether one or several fields of a dtype are nested.

Parameters
----------
ndtype : dtype
    Data-type of a structured array.

Raises
------
AttributeError
    If `ndtype` does not have a `names` attribute.

Examples
--------
>>> dt = np.dtype([('name', 'S4'), ('x', float), ('y', float)])
>>> np.lib._iotools.has_nested_fields(dt)
False\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1__iotools_a4ecb79a687b0f134273b11e96703f23f}\label{namespacenumpy_1_1lib_1_1__iotools_a4ecb79a687b0f134273b11e96703f23f}} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!str2bool@{str2bool}}
\index{str2bool@{str2bool}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{str2bool()}{str2bool()}}
{\footnotesize\ttfamily def numpy.\+lib.\+\_\+iotools.\+str2bool (\begin{DoxyParamCaption}\item[{}]{value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Tries to transform a string supposed to represent a boolean to a boolean.

Parameters
----------
value : str
    The string that is transformed to a boolean.

Returns
-------
boolval : bool
    The boolean representation of `value`.

Raises
------
ValueError
    If the string is not 'True' or 'False' (case independent)

Examples
--------
>>> np.lib._iotools.str2bool('TRUE')
True
>>> np.lib._iotools.str2bool('false')
False\end{DoxyVerb}
 