\hypertarget{namespacenumpy_1_1core_1_1numerictypes}{}\doxysection{numpy.\+core.\+numerictypes Namespace Reference}
\label{namespacenumpy_1_1core_1_1numerictypes}\index{numpy.core.numerictypes@{numpy.core.numerictypes}}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}numerictypes: Define the numeric type objects

This module is designed so "from numerictypes import \\*" is safe.
Exported symbols include:

  Dictionary with all registered number types (including aliases):
    typeDict

  Type objects (not all will be available, depends on platform):
      see variable sctypes for which ones you have

    Bit-width names

    int8 int16 int32 int64 int128
    uint8 uint16 uint32 uint64 uint128
    float16 float32 float64 float96 float128 float256
    complex32 complex64 complex128 complex192 complex256 complex512
    datetime64 timedelta64

    c-based names

    bool_

    object_

    void, str_, unicode_

    byte, ubyte,
    short, ushort
    intc, uintc,
    intp, uintp,
    int_, uint,
    longlong, ulonglong,

    single, csingle,
    float_, complex_,
    longfloat, clongfloat,

   As part of the type-hierarchy:    xx -- is bit-width

   generic
     +-> bool_                                  (kind=b)
     +-> number
     |   +-> integer
     |   |   +-> signedinteger     (intxx)      (kind=i)
     |   |   |     byte
     |   |   |     short
     |   |   |     intc
     |   |   |     intp            int0
     |   |   |     int_
     |   |   |     longlong
     |   |   \\-> unsignedinteger  (uintxx)     (kind=u)
     |   |         ubyte
     |   |         ushort
     |   |         uintc
     |   |         uintp           uint0
     |   |         uint_
     |   |         ulonglong
     |   +-> inexact
     |       +-> floating          (floatxx)    (kind=f)
     |       |     half
     |       |     single
     |       |     float_          (double)
     |       |     longfloat
     |       \\-> complexfloating  (complexxx)  (kind=c)
     |             csingle         (singlecomplex)
     |             complex_        (cfloat, cdouble)
     |             clongfloat      (longcomplex)
     +-> flexible
     |   +-> character
     |   |     str_     (string_, bytes_)       (kind=S)    [Python 2]
     |   |     unicode_                         (kind=U)    [Python 2]
     |   |
     |   |     bytes_   (string_)               (kind=S)    [Python 3]
     |   |     str_     (unicode_)              (kind=U)    [Python 3]
     |   |
     |   \\-> void                              (kind=V)
     \\-> object_ (not used much)               (kind=O)\end{DoxyVerb}
 \doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1numerictypes_1_1__typedict}{\+\_\+typedict}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a97df80194c7466a06b95f037f0d5a844}{maximum\+\_\+sctype}} (t)
\item 
def \mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_ac0d06f07b4d9348f62cd776c5a4dfed1}{issctype}} (rep)
\item 
def \mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a4112132097e16025a598ee650fdca003}{obj2sctype}} (rep, default=None)
\item 
def \mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_aabfb2145123e09bd184960c3f238b9db}{issubclass\+\_\+}} (arg1, arg2)
\item 
def \mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a248957fb69c8b2fee6ecc1ef38266c88}{issubsctype}} (arg1, arg2)
\item 
def \mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a42ed83d8a157a361cc678587b9c64ec3}{issubdtype}} (arg1, arg2)
\item 
def \mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a0fc02b9c8ebbf34f43da02fd841e1e28}{sctype2char}} (sctype)
\item 
def \mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a7a32e4cf109ee7b1a687ab3555e98898}{find\+\_\+common\+\_\+type}} (array\+\_\+types, scalar\+\_\+types)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a2b174847e4107b9e121d3c59cdf533ab}\label{namespacenumpy_1_1core_1_1numerictypes_a2b174847e4107b9e121d3c59cdf533ab}} 
{\bfseries generic} = all\+Types\mbox{[}\textquotesingle{}generic\textquotesingle{}\mbox{]}
\item 
list {\bfseries generic\+Type\+Rank}
\item 
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a07c1df771e775b51368c44e834e759d7}\label{namespacenumpy_1_1core_1_1numerictypes_a07c1df771e775b51368c44e834e759d7}} 
{\bfseries nbytes} = \mbox{\hyperlink{classnumpy_1_1core_1_1numerictypes_1_1__typedict}{\+\_\+typedict}}()
\item 
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a800a45743c8e0f4aec5b624c45232091}\label{namespacenumpy_1_1core_1_1numerictypes_a800a45743c8e0f4aec5b624c45232091}} 
{\bfseries cast} = \mbox{\hyperlink{classnumpy_1_1core_1_1numerictypes_1_1__typedict}{\+\_\+typedict}}()
\item 
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_af7a40df6735224194004fe9d7a2b80d4}\label{namespacenumpy_1_1core_1_1numerictypes_af7a40df6735224194004fe9d7a2b80d4}} 
{\bfseries x}
\item 
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a487d35c8a6e2a81ebb15722142c54b9c}\label{namespacenumpy_1_1core_1_1numerictypes_a487d35c8a6e2a81ebb15722142c54b9c}} 
{\bfseries k}
\item 
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a0c806c31bd62329acf3f0a9e6ada3912}\label{namespacenumpy_1_1core_1_1numerictypes_a0c806c31bd62329acf3f0a9e6ada3912}} 
{\bfseries copy}
\item 
list {\bfseries Scalar\+Type}
\item 
dictionary {\bfseries typecodes}
\item 
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a810a50e9f22081beeaea93490623c5e9}\label{namespacenumpy_1_1core_1_1numerictypes_a810a50e9f22081beeaea93490623c5e9}} 
{\bfseries type\+Dict} = sctype\+Dict
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a7a32e4cf109ee7b1a687ab3555e98898}\label{namespacenumpy_1_1core_1_1numerictypes_a7a32e4cf109ee7b1a687ab3555e98898}} 
\index{numpy.core.numerictypes@{numpy.core.numerictypes}!find\_common\_type@{find\_common\_type}}
\index{find\_common\_type@{find\_common\_type}!numpy.core.numerictypes@{numpy.core.numerictypes}}
\doxysubsubsection{\texorpdfstring{find\_common\_type()}{find\_common\_type()}}
{\footnotesize\ttfamily def numpy.\+core.\+numerictypes.\+find\+\_\+common\+\_\+type (\begin{DoxyParamCaption}\item[{}]{array\+\_\+types,  }\item[{}]{scalar\+\_\+types }\end{DoxyParamCaption})}

\begin{DoxyVerb}Determine common type following standard coercion rules.

Parameters
----------
array_types : sequence
    A list of dtypes or dtype convertible objects representing arrays.
scalar_types : sequence
    A list of dtypes or dtype convertible objects representing scalars.

Returns
-------
datatype : dtype
    The common data type, which is the maximum of `array_types` ignoring
    `scalar_types`, unless the maximum of `scalar_types` is of a
    different kind (`dtype.kind`). If the kind is not understood, then
    None is returned.

See Also
--------
dtype, common_type, can_cast, mintypecode

Examples
--------
>>> np.find_common_type([], [np.int64, np.float32, complex])
dtype('complex128')
>>> np.find_common_type([np.int64, np.float32], [])
dtype('float64')

The standard casting rules ensure that a scalar cannot up-cast an
array unless the scalar is of a fundamentally different kind of data
(i.e. under a different hierarchy in the data type hierarchy) then
the array:

>>> np.find_common_type([np.float32], [np.int64, np.float64])
dtype('float32')

Complex is of a different type, so it up-casts the float in the
`array_types` argument:

>>> np.find_common_type([np.float32], [complex])
dtype('complex128')

Type specifier strings are convertible to dtypes and can therefore
be used instead of dtypes:

>>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])
dtype('complex128')\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_ac0d06f07b4d9348f62cd776c5a4dfed1}\label{namespacenumpy_1_1core_1_1numerictypes_ac0d06f07b4d9348f62cd776c5a4dfed1}} 
\index{numpy.core.numerictypes@{numpy.core.numerictypes}!issctype@{issctype}}
\index{issctype@{issctype}!numpy.core.numerictypes@{numpy.core.numerictypes}}
\doxysubsubsection{\texorpdfstring{issctype()}{issctype()}}
{\footnotesize\ttfamily def numpy.\+core.\+numerictypes.\+issctype (\begin{DoxyParamCaption}\item[{}]{rep }\end{DoxyParamCaption})}

\begin{DoxyVerb}Determines whether the given object represents a scalar data-type.

Parameters
----------
rep : any
    If `rep` is an instance of a scalar dtype, True is returned. If not,
    False is returned.

Returns
-------
out : bool
    Boolean result of check whether `rep` is a scalar dtype.

See Also
--------
issubsctype, issubdtype, obj2sctype, sctype2char

Examples
--------
>>> np.issctype(np.int32)
True
>>> np.issctype(list)
False
>>> np.issctype(1.1)
False

Strings are also a scalar type:

>>> np.issctype(np.dtype('str'))
True\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_aabfb2145123e09bd184960c3f238b9db}\label{namespacenumpy_1_1core_1_1numerictypes_aabfb2145123e09bd184960c3f238b9db}} 
\index{numpy.core.numerictypes@{numpy.core.numerictypes}!issubclass\_@{issubclass\_}}
\index{issubclass\_@{issubclass\_}!numpy.core.numerictypes@{numpy.core.numerictypes}}
\doxysubsubsection{\texorpdfstring{issubclass\_()}{issubclass\_()}}
{\footnotesize\ttfamily def numpy.\+core.\+numerictypes.\+issubclass\+\_\+ (\begin{DoxyParamCaption}\item[{}]{arg1,  }\item[{}]{arg2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Determine if a class is a subclass of a second class.

`issubclass_` is equivalent to the Python built-in ``issubclass``,
except that it returns False instead of raising a TypeError if one
of the arguments is not a class.

Parameters
----------
arg1 : class
    Input class. True is returned if `arg1` is a subclass of `arg2`.
arg2 : class or tuple of classes.
    Input class. If a tuple of classes, True is returned if `arg1` is a
    subclass of any of the tuple elements.

Returns
-------
out : bool
    Whether `arg1` is a subclass of `arg2` or not.

See Also
--------
issubsctype, issubdtype, issctype

Examples
--------
>>> np.issubclass_(np.int32, int)
False
>>> np.issubclass_(np.int32, float)
False
>>> np.issubclass_(np.float64, float)
True\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a42ed83d8a157a361cc678587b9c64ec3}\label{namespacenumpy_1_1core_1_1numerictypes_a42ed83d8a157a361cc678587b9c64ec3}} 
\index{numpy.core.numerictypes@{numpy.core.numerictypes}!issubdtype@{issubdtype}}
\index{issubdtype@{issubdtype}!numpy.core.numerictypes@{numpy.core.numerictypes}}
\doxysubsubsection{\texorpdfstring{issubdtype()}{issubdtype()}}
{\footnotesize\ttfamily def numpy.\+core.\+numerictypes.\+issubdtype (\begin{DoxyParamCaption}\item[{}]{arg1,  }\item[{}]{arg2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if first argument is a typecode lower/equal in type hierarchy.

This is like the builtin :func:`issubclass`, but for `dtype`\ s.

Parameters
----------
arg1, arg2 : dtype_like
    `dtype` or object coercible to one

Returns
-------
out : bool

See Also
--------
:ref:`arrays.scalars` : Overview of the numpy type hierarchy.
issubsctype, issubclass_

Examples
--------
`issubdtype` can be used to check the type of arrays:

>>> ints = np.array([1, 2, 3], dtype=np.int32)
>>> np.issubdtype(ints.dtype, np.integer)
True
>>> np.issubdtype(ints.dtype, np.floating)
False

>>> floats = np.array([1, 2, 3], dtype=np.float32)
>>> np.issubdtype(floats.dtype, np.integer)
False
>>> np.issubdtype(floats.dtype, np.floating)
True

Similar types of different sizes are not subdtypes of each other:

>>> np.issubdtype(np.float64, np.float32)
False
>>> np.issubdtype(np.float32, np.float64)
False

but both are subtypes of `floating`:

>>> np.issubdtype(np.float64, np.floating)
True
>>> np.issubdtype(np.float32, np.floating)
True

For convenience, dtype-like objects are allowed too:

>>> np.issubdtype('S1', np.string_)
True
>>> np.issubdtype('i4', np.signedinteger)
True\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a248957fb69c8b2fee6ecc1ef38266c88}\label{namespacenumpy_1_1core_1_1numerictypes_a248957fb69c8b2fee6ecc1ef38266c88}} 
\index{numpy.core.numerictypes@{numpy.core.numerictypes}!issubsctype@{issubsctype}}
\index{issubsctype@{issubsctype}!numpy.core.numerictypes@{numpy.core.numerictypes}}
\doxysubsubsection{\texorpdfstring{issubsctype()}{issubsctype()}}
{\footnotesize\ttfamily def numpy.\+core.\+numerictypes.\+issubsctype (\begin{DoxyParamCaption}\item[{}]{arg1,  }\item[{}]{arg2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Determine if the first argument is a subclass of the second argument.

Parameters
----------
arg1, arg2 : dtype or dtype specifier
    Data-types.

Returns
-------
out : bool
    The result.

See Also
--------
issctype, issubdtype, obj2sctype

Examples
--------
>>> np.issubsctype('S8', str)
False
>>> np.issubsctype(np.array([1]), int)
True
>>> np.issubsctype(np.array([1]), float)
False\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a97df80194c7466a06b95f037f0d5a844}\label{namespacenumpy_1_1core_1_1numerictypes_a97df80194c7466a06b95f037f0d5a844}} 
\index{numpy.core.numerictypes@{numpy.core.numerictypes}!maximum\_sctype@{maximum\_sctype}}
\index{maximum\_sctype@{maximum\_sctype}!numpy.core.numerictypes@{numpy.core.numerictypes}}
\doxysubsubsection{\texorpdfstring{maximum\_sctype()}{maximum\_sctype()}}
{\footnotesize\ttfamily def numpy.\+core.\+numerictypes.\+maximum\+\_\+sctype (\begin{DoxyParamCaption}\item[{}]{t }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the scalar type of highest precision of the same kind as the input.

Parameters
----------
t : dtype or dtype specifier
    The input data type. This can be a `dtype` object or an object that
    is convertible to a `dtype`.

Returns
-------
out : dtype
    The highest precision data type of the same kind (`dtype.kind`) as `t`.

See Also
--------
obj2sctype, mintypecode, sctype2char
dtype

Examples
--------
>>> np.maximum_sctype(int)
<class 'numpy.int64'>
>>> np.maximum_sctype(np.uint8)
<class 'numpy.uint64'>
>>> np.maximum_sctype(complex)
<class 'numpy.complex256'> # may vary

>>> np.maximum_sctype(str)
<class 'numpy.str_'>

>>> np.maximum_sctype('i2')
<class 'numpy.int64'>
>>> np.maximum_sctype('f4')
<class 'numpy.float128'> # may vary\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a4112132097e16025a598ee650fdca003}\label{namespacenumpy_1_1core_1_1numerictypes_a4112132097e16025a598ee650fdca003}} 
\index{numpy.core.numerictypes@{numpy.core.numerictypes}!obj2sctype@{obj2sctype}}
\index{obj2sctype@{obj2sctype}!numpy.core.numerictypes@{numpy.core.numerictypes}}
\doxysubsubsection{\texorpdfstring{obj2sctype()}{obj2sctype()}}
{\footnotesize\ttfamily def numpy.\+core.\+numerictypes.\+obj2sctype (\begin{DoxyParamCaption}\item[{}]{rep,  }\item[{}]{default = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the scalar dtype or NumPy equivalent of Python type of an object.

Parameters
----------
rep : any
    The object of which the type is returned.
default : any, optional
    If given, this is returned for objects whose types can not be
    determined. If not given, None is returned for those objects.

Returns
-------
dtype : dtype or Python type
    The data type of `rep`.

See Also
--------
sctype2char, issctype, issubsctype, issubdtype, maximum_sctype

Examples
--------
>>> np.obj2sctype(np.int32)
<class 'numpy.int32'>
>>> np.obj2sctype(np.array([1., 2.]))
<class 'numpy.float64'>
>>> np.obj2sctype(np.array([1.j]))
<class 'numpy.complex128'>

>>> np.obj2sctype(dict)
<class 'numpy.object_'>
>>> np.obj2sctype('string')

>>> np.obj2sctype(1, default=list)
<class 'list'>\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a0fc02b9c8ebbf34f43da02fd841e1e28}\label{namespacenumpy_1_1core_1_1numerictypes_a0fc02b9c8ebbf34f43da02fd841e1e28}} 
\index{numpy.core.numerictypes@{numpy.core.numerictypes}!sctype2char@{sctype2char}}
\index{sctype2char@{sctype2char}!numpy.core.numerictypes@{numpy.core.numerictypes}}
\doxysubsubsection{\texorpdfstring{sctype2char()}{sctype2char()}}
{\footnotesize\ttfamily def numpy.\+core.\+numerictypes.\+sctype2char (\begin{DoxyParamCaption}\item[{}]{sctype }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the string representation of a scalar dtype.

Parameters
----------
sctype : scalar dtype or object
    If a scalar dtype, the corresponding string character is
    returned. If an object, `sctype2char` tries to infer its scalar type
    and then return the corresponding string character.

Returns
-------
typechar : str
    The string character corresponding to the scalar type.

Raises
------
ValueError
    If `sctype` is an object for which the type can not be inferred.

See Also
--------
obj2sctype, issctype, issubsctype, mintypecode

Examples
--------
>>> for sctype in [np.int32, np.double, np.complex_, np.string_, np.ndarray]:
...     print(np.sctype2char(sctype))
l # may vary
d
D
S
O

>>> x = np.array([1., 2-1.j])
>>> np.sctype2char(x)
'D'
>>> np.sctype2char(list)
'O'\end{DoxyVerb}
 

\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a6c48d8df1f06c8f76e23d1e0a0ead857}\label{namespacenumpy_1_1core_1_1numerictypes_a6c48d8df1f06c8f76e23d1e0a0ead857}} 
\index{numpy.core.numerictypes@{numpy.core.numerictypes}!genericTypeRank@{genericTypeRank}}
\index{genericTypeRank@{genericTypeRank}!numpy.core.numerictypes@{numpy.core.numerictypes}}
\doxysubsubsection{\texorpdfstring{genericTypeRank}{genericTypeRank}}
{\footnotesize\ttfamily list numpy.\+core.\+numerictypes.\+generic\+Type\+Rank}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 =  [\textcolor{stringliteral}{'bool'}, \textcolor{stringliteral}{'int8'}, \textcolor{stringliteral}{'uint8'}, \textcolor{stringliteral}{'int16'}, \textcolor{stringliteral}{'uint16'},}
\DoxyCodeLine{2                    \textcolor{stringliteral}{'int32'}, \textcolor{stringliteral}{'uint32'}, \textcolor{stringliteral}{'int64'}, \textcolor{stringliteral}{'uint64'}, \textcolor{stringliteral}{'int128'},}
\DoxyCodeLine{3                    \textcolor{stringliteral}{'uint128'}, \textcolor{stringliteral}{'float16'},}
\DoxyCodeLine{4                    \textcolor{stringliteral}{'float32'}, \textcolor{stringliteral}{'float64'}, \textcolor{stringliteral}{'float80'}, \textcolor{stringliteral}{'float96'}, \textcolor{stringliteral}{'float128'},}
\DoxyCodeLine{5                    \textcolor{stringliteral}{'float256'},}
\DoxyCodeLine{6                    \textcolor{stringliteral}{'complex32'}, \textcolor{stringliteral}{'complex64'}, \textcolor{stringliteral}{'complex128'}, \textcolor{stringliteral}{'complex160'},}
\DoxyCodeLine{7                    \textcolor{stringliteral}{'complex192'}, \textcolor{stringliteral}{'complex256'}, \textcolor{stringliteral}{'complex512'}, \textcolor{stringliteral}{'object'}]}

\end{DoxyCode}
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a25377d86d755774d05463138022a5043}\label{namespacenumpy_1_1core_1_1numerictypes_a25377d86d755774d05463138022a5043}} 
\index{numpy.core.numerictypes@{numpy.core.numerictypes}!ScalarType@{ScalarType}}
\index{ScalarType@{ScalarType}!numpy.core.numerictypes@{numpy.core.numerictypes}}
\doxysubsubsection{\texorpdfstring{ScalarType}{ScalarType}}
{\footnotesize\ttfamily list numpy.\+core.\+numerictypes.\+Scalar\+Type}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 =  [\_types.IntType, \_types.FloatType, \_types.ComplexType,}
\DoxyCodeLine{2                   \_types.LongType, \_types.BooleanType,}
\DoxyCodeLine{3                    \_types.StringType, \_types.UnicodeType, \_types.BufferType]}

\end{DoxyCode}
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1numerictypes_a26b60f96dc8129a0e828a61aab483008}\label{namespacenumpy_1_1core_1_1numerictypes_a26b60f96dc8129a0e828a61aab483008}} 
\index{numpy.core.numerictypes@{numpy.core.numerictypes}!typecodes@{typecodes}}
\index{typecodes@{typecodes}!numpy.core.numerictypes@{numpy.core.numerictypes}}
\doxysubsubsection{\texorpdfstring{typecodes}{typecodes}}
{\footnotesize\ttfamily dictionary numpy.\+core.\+numerictypes.\+typecodes}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 =  \{\textcolor{stringliteral}{'Character'}:\textcolor{stringliteral}{'c'},}
\DoxyCodeLine{2              \textcolor{stringliteral}{'Integer'}:\textcolor{stringliteral}{'bhilqp'},}
\DoxyCodeLine{3              \textcolor{stringliteral}{'UnsignedInteger'}:\textcolor{stringliteral}{'BHILQP'},}
\DoxyCodeLine{4              \textcolor{stringliteral}{'Float'}:\textcolor{stringliteral}{'efdg'},}
\DoxyCodeLine{5              \textcolor{stringliteral}{'Complex'}:\textcolor{stringliteral}{'FDG'},}
\DoxyCodeLine{6              \textcolor{stringliteral}{'AllInteger'}:\textcolor{stringliteral}{'bBhHiIlLqQpP'},}
\DoxyCodeLine{7              \textcolor{stringliteral}{'AllFloat'}:\textcolor{stringliteral}{'efdgFDG'},}
\DoxyCodeLine{8              \textcolor{stringliteral}{'Datetime'}: \textcolor{stringliteral}{'Mm'},}
\DoxyCodeLine{9              \textcolor{stringliteral}{'All'}:\textcolor{stringliteral}{'?bhilqpBHILQPefdgFDGSUVOMm'}\}}

\end{DoxyCode}
